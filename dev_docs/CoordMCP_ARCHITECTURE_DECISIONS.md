# CoordMCP - Architecture Decisions & Design Rationale

## ADR-001: JSON-Based Storage vs. Database

**Status:** Accepted  
**Date:** 2024-02-09

### Decision
Use JSON files for data storage instead of a traditional database.

### Rationale
1. **Time Constraint**: 5-day development timeline requires minimal setup
2. **Simplicity**: No database installation, migrations, or complex queries
3. **Portability**: Easy to backup, version, and inspect files
4. **Future Migration**: Abstraction layer allows swapping to PostgreSQL/MongoDB later
5. **Debugging**: Human-readable files make troubleshooting easy

### Tradeoffs
- ‚ùå Not optimized for concurrent writes (mitigated by FileTracker)
- ‚ùå Scaling limited to 100k+ records (not needed for 5-day MVP)
- ‚úÖ Simple enough for single-agent, multi-agent testing

### Implementation
- `storage/base.py` defines abstract interface
- `storage/json_adapter.py` implements JSON persistence
- All save operations use atomic write pattern

---

## ADR-002: Abstraction Layer for Storage

**Status:** Accepted

### Decision
Create abstract `StorageBackend` interface, with JSON as first implementation.

### Rationale
1. **Future Extensibility**: Vector DBs, PostgreSQL, MongoDB can be plugged in
2. **Testing**: Easy to mock storage for unit tests
3. **Separation of Concerns**: Tools don't know about storage format
4. **No "Rip and Replace"**: Gradual migration possible

### Implementation
```python
class StorageBackend(ABC):
    @abstractmethod
    def save(self, key: str, data: Dict) -> bool
    @abstractmethod
    def load(self, key: str) -> Optional[Dict]
    # ... more methods
```

---

## ADR-003: FastMCP Over Direct Python API

**Status:** Accepted

### Decision
Use FastMCP for tool/resource definition instead of building a raw Python API.

### Rationale
1. **Agent Integration**: FastMCP is designed for LLM agents
2. **Standard Protocol**: Works with Opencode, Cursor, Claude Code without modification
3. **Future Agents**: Custom agents automatically supported
4. **Schema Validation**: FastMCP handles input/output validation
5. **Built-in Features**: Pagination, streaming ready to add

### Not Considered
- REST API (would need separate FastAPI server, adds complexity)
- gRPC (overly complex, not agent-native)
- Direct Python imports (not available to agents)

---

## ADR-004: No LLM Calls for Architecture Recommendations

**Status:** Accepted

### Decision
All architecture recommendations generated by rule-based logic, not API calls to external LLMs.

### Rationale
1. **Cost**: No API calls = no cost at scale
2. **Performance**: Instant recommendations
3. **Reliability**: No network dependencies
4. **Feasibility**: Rules sufficient for 5-day timeline
5. **Future Enhancement**: Can add embeddings/vector search later

### How It Works
1. Analyzer checks current architecture
2. Recommender matches feature against design patterns
3. Applies SOLID principles
4. Suggests file/module structure
5. Provides implementation guide

### Design Patterns Included (Hardcoded)
- CRUD (Create, Read, Update, Delete)
- MVC (Model-View-Controller)
- Repository (Data access abstraction)
- Service (Business logic layer)
- Factory (Object creation)
- Observer (Event-driven)
- Adapter (Interface adaptation)

---

## ADR-005: File-Level Locking for Conflict Prevention

**Status:** Accepted

### Decision
Use optimistic file-level locking to prevent agent conflicts.

### Rationale
1. **Multi-Agent Safety**: Only one agent can modify a file at once
2. **Simple**: No complex distributed lock mechanisms
3. **User-Friendly**: Agents know what's locked before starting
4. **Timeout**: Stale locks auto-cleaned after 24 hours
5. **Override**: Agents can force-unlock if needed

### How It Works
1. Agent locks files before working: `lock_files(agent_id, files)`
2. System prevents concurrent locks on same files
3. Agents check locks before starting: `get_locked_files(project_id)`
4. Agents unlock when done: `unlock_files(agent_id, files)`
5. Stale locks cleaned automatically

### Limitations
- Requires agent discipline (can't enforce lock usage)
- Doesn't prevent accidental overwrites in actual code repo
- Designed for coordination, not hard enforcement

---

## ADR-006: Hierarchical Storage Keys

**Status:** Accepted

### Decision
Use nested directory structure for storage keys (e.g., `memory/proj1/decisions.json`).

### Rationale
1. **Organization**: Related data stored together
2. **Scoping**: Easy to query all data for a project
3. **Performance**: Minimal file I/O, no indexing needed
4. **Debugging**: Can browse file system directly
5. **Backup**: Can back up by project

### Structure
```
data/
‚îú‚îÄ‚îÄ memory/{project_id}/
‚îÇ   ‚îú‚îÄ‚îÄ decisions.json
‚îÇ   ‚îú‚îÄ‚îÄ tech_stack.json
‚îÇ   ‚îú‚îÄ‚îÄ architecture.json
‚îÇ   ‚îú‚îÄ‚îÄ recent_changes.json
‚îÇ   ‚îî‚îÄ‚îÄ file_metadata.json
‚îú‚îÄ‚îÄ agents/{agent_id}/
‚îÇ   ‚îú‚îÄ‚îÄ profile.json
‚îÇ   ‚îú‚îÄ‚îÄ context.json
‚îÇ   ‚îú‚îÄ‚îÄ locked_files.json
‚îÇ   ‚îî‚îÄ‚îÄ session_log.json
‚îî‚îÄ‚îÄ global/
    ‚îú‚îÄ‚îÄ agent_registry.json
    ‚îî‚îÄ‚îÄ project_registry.json
```

---

## ADR-007: Timestamp Format (ISO 8601)

**Status:** Accepted

### Decision
Use ISO 8601 format for all timestamps: `2024-02-09T10:30:00Z`

### Rationale
1. **Standard**: Universal format, no ambiguity
2. **Timezone-aware**: Always UTC with Z suffix
3. **Sortable**: String comparison works
4. **Debuggable**: Human readable
5. **JSON-native**: No special serialization needed

### Implementation
```python
from datetime import datetime, timezone
timestamp = datetime.now(timezone.utc).isoformat()
# Result: "2024-02-09T10:30:00.123456+00:00"
# Strip microseconds if needed: .split('.')[0] + 'Z'
```

---

## ADR-008: Tool Response Format

**Status:** Accepted

### Decision
All tools return consistent JSON response format:
```json
{
    "success": true/false,
    "data": {...},
    "error": "message",
    "error_type": "ErrorType",
    "suggestions": ["fix1", "fix2"]
}
```

### Rationale
1. **Consistency**: Agents expect uniform interface
2. **Debugging**: Clear error messages and suggestions
3. **Success Determination**: Simple boolean check
4. **Actionability**: Suggestions help agents fix issues
5. **Extensibility**: Can add fields without breaking agents

### Error Response Example
```json
{
    "success": false,
    "error": "File is locked by agent-001",
    "error_type": "FileLockError",
    "suggestions": [
        "Wait for agent-001 to unlock the file",
        "Use force_unlock if necessary",
        "Check agent-001's context with get_agent_context"
    ]
}
```

---

## ADR-009: Recommendation ID Structure

**Status:** Accepted

### Decision
Each architecture recommendation gets a unique UUID, stored in `recommendations/{rec_id}/`.

### Rationale
1. **Traceability**: Can reference specific recommendation
2. **Versioning**: Can keep old recommendations for comparison
3. **Status Tracking**: Can mark as pending/approved/implemented
4. **Iteration**: Can create multiple versions for same feature

### Workflow
1. Agent requests recommendation ‚Üí returns `recommendation_id`
2. Agent reviews recommendation
3. Agent implements changes
4. Agent calls `update_architecture(recommendation_id)` to mark complete

---

## ADR-010: Project vs. Global Scope

**Status:** Accepted

### Decision
Data is primarily project-scoped, with global registry for lookup.

### Rationale
1. **Isolation**: Multi-project setup doesn't interfere
2. **Scalability**: Each project can grow independently
3. **Performance**: Don't load all projects' data unless needed
4. **Backup**: Can backup individual projects
5. **Multi-tenancy**: Ready for future team setups

### Structure
```
Project-Scoped:
- Decisions, tech stack, architecture, file metadata
- Recent changes (per project)
- Module information (per project)

Global Scope:
- Agent registry (all agents)
- Project registry (all projects)
- Configuration (system-wide)
```

---

## ADR-011: Agent Registration vs. Auto-Discovery

**Status:** Accepted

### Decision
Agents must explicitly register with `register_agent()` before using system.

### Rationale
1. **Explicit Tracking**: Know which agents are active
2. **Capabilities Recording**: Each agent declares what it can do
3. **Version Control**: Track agent versions
4. **Deprecation**: Can mark old agents as deprecated
5. **Audit Trail**: Know who did what

### Workflow
1. New agent: `register_agent("my-agent", "opencode", ["write", "refactor"])`
2. System returns: `agent_id` (UUID)
3. Agent stores ID for future calls
4. Agent uses ID in all subsequent operations

---

## ADR-012: Decision vs. Context vs. Change

**Status:** Accepted

### Decision
Distinguish between three concepts:
- **Decision**: Major architectural/technical choice (permanent)
- **Context**: What an agent is currently working on (session)
- **Change**: Actual file modification (logged)

### Rationale
1. **Different Lifecycles**: Decisions persist, contexts are temporary
2. **Different Use Cases**: Decisions inform future work, context prevents conflicts
3. **Querying**: Can search each independently
4. **Relationships**: Changes reference decisions they implement

### Relationships
```
Decision (once)
  ‚Üì
Referenced by ‚Üí Change (many)
  ‚Üì
Tracked in ‚Üí Context (during session)
```

---

## ADR-013: Recommendation Engine Algorithm

**Status:** Accepted

### Decision
Use multi-step algorithm (no LLM needed):

```
1. Analyze current architecture
2. Identify relevant modules
3. Match feature type against patterns
4. Apply SOLID principles
5. Check for code reuse opportunities
6. Suggest file structure
7. Suggest code structure
8. Generate implementation steps
```

### Why This Works
- Each step is deterministic
- Results are explainable
- Can be iterated on easily
- Doesn't require training data

### Example: User Authentication Feature
```
1. Analyze: See existing models, services
2. Match Pattern: "User Authentication" ‚Üí Service pattern
3. Suggest Files:
   - src/auth/models.py (User model)
   - src/auth/services.py (Auth service)
   - src/auth/routes.py (API endpoints)
4. Suggest Structure:
   - User class with password hashing
   - AuthService with login/logout/verify
   - Dependency injection
5. Generate Steps:
   - Create User model
   - Add password hashing
   - Create AuthService
   - Add routes
   - Write tests
```

---

## ADR-014: Module Boundaries

**Status:** Accepted

### Decision
Modules are logical groupings with clear responsibilities.

### Rationale
1. **Understandability**: Each module has single purpose
2. **Independence**: Modules can be developed separately
3. **Testing**: Easy to test module in isolation
4. **Reusability**: Modules can be moved/copied

### Example Module
```
auth/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ models.py          (User, Role, Permission)
‚îú‚îÄ‚îÄ services.py        (AuthService, PasswordService)
‚îú‚îÄ‚îÄ routes.py          (FastAPI routes)
‚îú‚îÄ‚îÄ exceptions.py      (Auth-specific errors)
‚îú‚îÄ‚îÄ utils.py           (Helpers)
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ test_models.py
    ‚îú‚îÄ‚îÄ test_services.py
    ‚îî‚îÄ‚îÄ test_routes.py
```

---

## ADR-015: Design Patterns as Hardcoded Reference

**Status:** Accepted

### Decision
Design patterns stored as hardcoded JSON/dicts in `architecture/patterns.py`.

### Rationale
1. **No Database Needed**: Patterns are static
2. **Versionable**: Can track pattern changes in git
3. **Extensible**: Easy to add new patterns
4. **Fast Access**: No I/O needed
5. **Type Safe**: Can use Python dataclasses

### Each Pattern Includes
- Description
- When to use
- File structure template
- Class structure template
- Code example
- Best practices
- Common pitfalls

---

## ADR-016: Change Log vs. Session Log

**Status:** Accepted

### Decision
Two separate logs:
- **Change Log**: All project changes (persisted, project-scoped)
- **Session Log**: Agent activity in current session (per-agent)

### Rationale
1. **Different Retention**: Changes permanent, sessions temporary
2. **Different Queries**: Search all changes, only recent for context
3. **Different Audiences**: Everyone sees changes, only agent sees session
4. **Performance**: Can clear sessions, keep changes

### Change Log Entry
```python
{
    "timestamp": "...",
    "file_path": "src/auth/models.py",
    "change_type": "create|modify|delete|refactor",
    "description": "Added User model with password hashing",
    "agent_id": "agent-001",
    "architecture_impact": "none|minor|significant"
}
```

### Session Log Entry
```python
{
    "timestamp": "...",
    "event": "file_created",
    "details": {"file": "src/auth/models.py"}
}
```

---

## ADR-017: Complexity Assessment (Simple)

**Status:** Accepted

### Decision
File complexity tracked as: low | medium | high (not cyclomatic complexity score).

### Rationale
1. **Simplicity**: No complex calculations needed
2. **Actionability**: Clear guidance (refactor if "high")
3. **Speed**: Fast to assess
4. **Future**: Can enhance with metrics later

### Assessment Guidelines
- **Low**: <200 LOC, single responsibility, <3 methods
- **Medium**: 200-500 LOC, 2-3 responsibilities, 3-7 methods
- **High**: >500 LOC, multiple responsibilities, >7 methods

---

## ADR-018: Agent Types and Extensibility

**Status:** Accepted

### Decision
Support predefined agent types: opencode, cursor, claude_code, custom.

### Rationale
1. **Known Integration**: Predefined types are tested
2. **Flexibility**: Custom type allows any future agent
3. **Capabilities**: Each type has default capabilities
4. **Tracking**: Can analyze by agent type

### Agent Types
```python
AGENT_TYPES = {
    "opencode": {
        "description": "Opencode coding agent",
        "default_capabilities": ["write", "refactor", "test", "analyze"]
    },
    "cursor": {
        "description": "Cursor IDE agent",
        "default_capabilities": ["write", "refactor", "analyze"]
    },
    "claude_code": {
        "description": "Claude Code command-line agent",
        "default_capabilities": ["write", "refactor", "test"]
    },
    "custom": {
        "description": "Custom agent",
        "default_capabilities": []
    }
}
```

---

## ADR-019: Data Validation Strategy

**Status:** Accepted

### Decision
Use Pydantic for automatic validation + custom validators for business logic.

### Rationale
1. **Automatic**: Type hints = validation
2. **Errors**: Clear error messages
3. **Serialization**: Auto JSON serialization
4. **IDE Support**: Type hints enable autocomplete
5. **Tests**: Validation catches bugs early

### Example
```python
from pydantic import BaseModel, Field, validator

class Decision(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid4()))
    title: str = Field(min_length=3, max_length=200)
    description: str
    status: Literal["active", "archived", "superseded"]
    
    @validator("title")
    def title_not_empty(cls, v):
        if not v.strip():
            raise ValueError("Title cannot be empty")
        return v.strip()
```

---

## ADR-020: Error Handling Philosophy

**Status:** Accepted

### Decision
- **Critical Errors**: Raise exceptions (fail fast)
- **Warnings**: Log but continue
- **Tool Responses**: Return error in response JSON

### Rationale
1. **Safety**: Critical errors stop bad operations
2. **Observability**: Warnings visible in logs
3. **Agent Friendly**: Tool responses don't crash agents

### Examples
```python
# Critical (raise)
if not project_exists:
    raise ProjectNotFoundError()

# Warning (log)
if lock_is_stale:
    logger.warning(f"Stale lock detected: {lock}")

# Tool response (don't raise)
return {
    "success": False,
    "error": "File is locked",
    "error_type": "FileLockError"
}
```

---

## Implementation Implications

### For Opencode:
1. ‚úÖ Stick to modular design - each module independent
2. ‚úÖ Use abstract classes early for extensibility
3. ‚úÖ Write validators for all data models
4. ‚úÖ Use consistent error handling patterns
5. ‚úÖ No external LLM calls in recommendations
6. ‚úÖ All timestamps in ISO 8601 UTC
7. ‚úÖ Atomic writes for JSON files
8. ‚úÖ Log all operations for debugging

### For Future Developers:
1. üìù Add new storage backends by extending `StorageBackend`
2. üìù Add new design patterns to `patterns.py`
3. üìù Add new agent types to agent type registry
4. üìù Add new tools without modifying existing ones
5. üìù Add vector DB for semantic search later

---

## Decisions Not Made (Deferred)

### Post-MVP (Future)
- [ ] Real-time collaboration
- [ ] Distributed locking (Redis)
- [ ] Vector DB for semantic search
- [ ] Web UI dashboard
- [ ] Git integration
- [ ] Analytics engine
- [ ] Advanced caching
- [ ] Rate limiting

These can be added without changing core design.

---

This ADR document provides the reasoning behind every major design decision in CoordMCP.
Use it to understand "why" when building features.
